# Script:      flow.py
# Description: Automated EDA Flow for ASIC Design
#              1. Verification (Icarus Verilog + Randomized Testing)
#              2. Synthesis (Yosys + Sky130 + Optimization + Area Reporting)
#              3. Timing Analysis (OpenSTA - Setup & Hold Constraints)

import os, re, csv, subprocess, sys, shutil

# --- CONFIGURATION ---
RESULTS_FILE = "ppa_summary.csv"
NETLIST_FILE = "alu_netlist.v"
LOG_FILE     = "synth.log"
CLOCK_PERIOD = 10.0  # Target: 100 MHz (10ns)

def run_step(name, cmd, env=None):
    print(f"--- Running {name} ---")
    try:
        # Run command. stdout=subprocess.DEVNULL hides the noise, but stderr is shown if it fails.
        subprocess.run(cmd, shell=True, check=True, env=env, stdout=subprocess.DEVNULL)
        print(f"‚úÖ {name} Complete")
        return True
    except subprocess.CalledProcessError:
        print(f"‚ùå {name} Failed")
        return False

# ==============================================================================
# STEP 1: FUNCTIONAL VERIFICATION
# ==============================================================================
# We compile the Verilog source (alu.v) and Testbench (tb.v) into a binary (alu_sim)
run_step("Compilation", "iverilog -o alu_sim alu.v tb.v")

# We run the binary. capture_output=True allows us to read the PASS/FAIL messages.
res = subprocess.run("vvp alu_sim", shell=True, capture_output=True, text=True)

# Print the simulation log so you can see "PASS" or "FAIL"
print(res.stdout)
if "FAIL" in res.stdout:
    print("‚ùå Simulation Failed. Aborting flow to prevent bad logic from being synthesized.")
    sys.exit(1)

# ==============================================================================
# STEP 2: LOGIC SYNTHESIS & OPTIMIZATION
# ==============================================================================
# This command chain does the heavy lifting:
# 1. read_verilog: Loads your code.
# 2. synth -top: Converts generic logic (AND/OR) from your code.
# 3. opt -purge: Removes unused logic to save space (Optimization).
# 4. dfflibmap: Maps Flip-Flops to Sky130 cells.
# 5. abc: Maps logic gates to Sky130 cells.
# 6. clean: Cleans up loose wires.
# 7. tee -o synth.log stat: Prints the chip size and SAVES it to a file.
yosys_cmd = (
    "yosys -p \""
    "read_verilog alu.v; "
    "synth -top alu; "
    "opt -purge; "
    "dfflibmap -liberty sky130.lib; "
    "abc -liberty sky130.lib; "
    "clean; "
    "write_verilog alu_netlist.v; "
    "tee -o synth.log stat -liberty sky130.lib\""
)

if not run_step("Synthesis (Yosys)", yosys_cmd):
    # If synthesis fails, print the version to help debug
    subprocess.run("yosys -V", shell=True)
    sys.exit(1)

# --- NEW: PARSE AREA STATS ---
# We open the log file we just created to find the "Chip area".
chip_area = "N/A"
gate_count = "N/A"

if os.path.exists(LOG_FILE):
    with open(LOG_FILE, "r") as f:
        content = f.read()
        # Regex to find: "Chip area for module '\alu': 1450.230000"
        m_area = re.search(r'Chip area for module.*:\s+([\d\.]+)', content)
        if m_area: 
            chip_area = m_area.group(1)
            # Estimate Gate Count: A standard NAND gate is roughly 10 um¬≤.
            # This is a standard industry estimation method.
            gate_count = int(float(chip_area) / 10) 

# ==============================================================================
# STEP 3: STATIC TIMING ANALYSIS (STA)
# ==============================================================================
possible_paths = [
    "sta", "opensta", 
    os.path.expanduser("~/OpenSTA/build/app/sta"),
    "/usr/local/bin/sta"
]
# Auto-detect where 'sta' is installed on your system
sta_tool = next((p for p in possible_paths if shutil.which(p) or (os.path.exists(p) and os.access(p, os.X_OK))), None)

# Initialize variables to N/A in case STA fails
setup_slack, hold_slack = "N/A", "N/A"
setup_crit_path, hold_crit_path = "N/A", "N/A"
violating_paths = 0

if sta_tool:
    print(f"‚ÑπÔ∏è  Using STA tool at: {sta_tool}")
    env = os.environ.copy()
    env["CLK_PERIOD"] = str(CLOCK_PERIOD)
    
    # Run the Tcl script that checks Setup and Hold
    run_step("STA (OpenSTA)", f"{sta_tool} run_sta.tcl", env)
    
    # Helper to read the reports generated by the Tcl script
    def parse_timing_report(filename):
        slack, path_delay = "N/A", "N/A"
        if os.path.exists(filename):
            with open(filename, "r") as f:
                content = f.read()
                # Find Slack: The time margin we have left (Positive is Good)
                m_slack = re.search(r'(-?[\d\.]+)\s+slack\s+\((MET|VIOLATED)\)', content)
                if m_slack: slack = m_slack.group(1)
                
                # Find Data Arrival: How long the signal actually takes
                m_path = re.search(r'([\d\.]+)\s+data arrival time', content)
                if m_path: path_delay = m_path.group(1)
        return slack, path_delay

    # 1. Parse Setup Report (Max Speed)
    setup_slack, setup_crit_path = parse_timing_report("timing_setup.rpt")

    # 2. Parse Hold Report (Stability)
    hold_slack, hold_crit_path = parse_timing_report("timing_hold.rpt")

    # 3. Count Violations (Did we fail anywhere?)
    if os.path.exists("violations.rpt"):
        with open("violations.rpt", "r") as f:
            violating_paths = f.read().count("VIOLATED")

    # Print a professional summary to the console
    print(f"\nüìä RESULTS (Clock: {CLOCK_PERIOD}ns)")
    print(f"   -> Setup Slack (WNS): {setup_slack} ns")
    print(f"   -> Hold Slack (WHS):  {hold_slack} ns")
    print(f"   -> Chip Area:         {chip_area} um¬≤")
    print(f"   -> Est. Gate Count:   ~{gate_count} gates")
    print(f"   -> Violating Paths:   {violating_paths}")

else:
    print("‚ö†Ô∏è STA Tool not found. Skipping timing.")

# ==============================================================================
# STEP 4: EXPORT REPORT
# ==============================================================================
# Save all metrics to a CSV file for your portfolio documentation
with open(RESULTS_FILE, "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerow(["Metric", "Value"])
    writer.writerow(["Verification", "PASS"])
    writer.writerow(["Clock Period", CLOCK_PERIOD])
    writer.writerow(["Setup Slack (WNS)", setup_slack])
    writer.writerow(["Hold Slack (WHS)", hold_slack])
    writer.writerow(["Chip Area (um^2)", chip_area])
    writer.writerow(["Est. Gate Count", gate_count])
    writer.writerow(["Violating Paths", violating_paths])

print(f"\n‚úÖ Final Report Saved: {RESULTS_FILE}")